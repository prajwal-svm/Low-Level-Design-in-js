# Understanding the Four Pillars of Object-Oriented Programming (OOP) in JavaScript

Object-oriented programming (OOP) is a programming paradigm centered around objects rather than functions. Its core principles help developers build robust, scalable, and maintainable code. In this post, we’ll dive into the four main principles of OOP:

- **Encapsulation**
- **Abstraction**
- **Inheritance**
- **Polymorphism**

All our examples will be in JavaScript.

---

## 1. Encapsulation and Data Hiding

Encapsulation is the mechanism of bundling data (attributes) and methods (functions) that operate on the data into a single unit, often a class. This process not only groups related information together but also restricts direct access to some of an object’s components, which is known as *data hiding*.

### Data Hiding

Data hiding protects an object’s internal state by preventing external components from directly accessing its data. Instead, a class exposes public methods (getters and setters) to interact with the hidden data. This safeguards the object against unintended interference and misuse.

### Encapsulation in JavaScript

With modern JavaScript (ES2022 and later), you can define private fields using the `#` syntax. Here’s an example that demonstrates encapsulation with a `Movie` class:

```js
class Movie {
  // Private fields
  #title;
  #year;
  #genre;

  constructor(title, year, genre) {
    this.#title = title;
    this.#year = year;
    this.#genre = genre;
  }

  // Getter for title
  getTitle() {
    return this.#title;
  }

  // Setter for title
  setTitle(newTitle) {
    this.#title = newTitle;
  }

  // Additional getters and setters for year and genre
  getYear() {
    return this.#year;
  }

  setYear(newYear) {
    this.#year = newYear;
  }

  getGenre() {
    return this.#genre;
  }

  setGenre(newGenre) {
    this.#genre = newGenre;
  }
}

const myMovie = new Movie("Inception", 2010, "Sci-Fi");
console.log(myMovie.getTitle()); // Output: Inception
// Direct access like myMovie.#title would result in a syntax error
```

In this example, the Movie class hides its internal data using private fields and exposes public methods to access or modify that data. This not only ensures data integrity but also makes the code easier to maintain.

2. Abstraction

Abstraction focuses on hiding the complex reality while exposing only the necessary parts of an object. It allows developers to work with higher-level concepts without worrying about the internal details of their implementation.

Abstraction in JavaScript

JavaScript doesn’t have built-in abstract classes like some other languages, but you can simulate abstraction by defining a base class with methods that are meant to be overridden by subclasses.

Consider a Shape class that serves as a blueprint for different shapes:

```js
class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new TypeError("Cannot instantiate abstract class Shape directly.");
    }
  }

  // Abstract method
  calculateArea() {
    throw new Error("Method 'calculateArea()' must be implemented.");
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  calculateArea() {
    return this.width * this.height;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  calculateArea() {
    return Math.PI * this.radius ** 2;
  }
}

const rectangle = new Rectangle(10, 5);
console.log("Rectangle area:", rectangle.calculateArea()); // 50

const circle = new Circle(7);
console.log("Circle area:", circle.calculateArea()); // ~153.94
```

In this code, the Shape class defines the common interface (calculateArea()) without providing a concrete implementation. Each subclass then provides its own implementation. This abstraction simplifies the interaction with various shapes.

3. Inheritance

Inheritance allows a new class to adopt the properties and behaviors (methods) of an existing class. It promotes code reuse and establishes a relationship between classes.

Inheritance in JavaScript

JavaScript supports inheritance through the extends keyword. Let’s see an example using an Animal class as a base class:

```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a sound.`);
  }
}

class Dog extends Animal {
  // Inherits the constructor and properties from Animal
  speak() {
    console.log(`${this.name} barks.`);
  }
}

class Cat extends Animal {
  speak() {
    console.log(`${this.name} meows.`);
  }
}

const dog = new Dog("Buddy");
dog.speak(); // Output: Buddy barks.

const cat = new Cat("Whiskers");
cat.speak(); // Output: Whiskers meows.
```

Here, the Dog and Cat classes inherit from Animal but override the speak() method to provide behavior specific to each animal. This demonstrates how inheritance facilitates both code reuse and customization.

4. Polymorphism

Polymorphism, meaning “many forms,” allows objects of different classes to be treated as objects of a common superclass. It enables a single interface to represent different underlying forms (data types).

Polymorphism in JavaScript

Polymorphism is often achieved through method overriding. By designing a common method in the base class that is overridden by each subclass, you can call the same method on different objects and get behavior specific to the actual object type.

Consider the following example with our Animal class:

```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a sound.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

class Cat extends Animal {
  speak() {
    console.log(`${this.name} meows.`);
  }
}

// An array of different animals
const animals = [new Dog("Buddy"), new Cat("Whiskers")];

// Each animal speaks according to its own implementation of speak()
animals.forEach(animal => animal.speak());
// Output:
// Buddy barks.
// Whiskers meows.
```

In this example, both Dog and Cat are treated as Animal objects. When the speak() method is called, the version defined in the corresponding subclass is executed, showcasing polymorphism in action.


