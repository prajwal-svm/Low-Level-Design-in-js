# Interface Segregation Principle (ISP)

## What is the Interface Segregation Principle?

The Interface Segregation Principle states:

> Clients should not be forced to depend upon interfaces they do not use.

In simpler terms, it's better to have many small, specific interfaces rather than a few large, general-purpose ones. This principle encourages breaking down large interfaces into smaller, more focused ones so that clients only need to know about the methods that are of interest to them.

Though JavaScript doesn't have formal interfaces like some other languages, we can still apply this principle using classes, inheritance, and duck typing.

## Why is ISP Important?

1. **Reduced coupling**: Clients depend only on what they actually use
2. **Improved maintainability**: Changes to one interface don't affect clients that don't use it
3. **Enhanced readability**: Smaller interfaces are easier to understand
4. **Better testability**: More focused interfaces are easier to mock and test
5. **Increased reusability**: Small, cohesive interfaces can be reused in more contexts

## ISP Violations: Signs and Symptoms

You might be violating ISP if:

- Classes implement methods they don't need just to satisfy an interface
- You find yourself creating "dummy" or empty method implementations
- Clients need to know about methods they don't use
- Changes to an interface affect many unrelated clients
- You have "fat" interfaces with many methods serving different purposes

## Examples of ISP in JavaScript

### Example 1: Basic ISP Violation

Let's start with an example of a "fat" interface that violates ISP:

```javascript
// A "fat" interface that violates ISP
class Machine {
  constructor() {
    if (this.constructor === Machine) {
      throw new Error("Machine is an abstract class and cannot be instantiated directly");
    }
  }
  
  print(document) {
    throw new Error("Method 'print()' must be implemented");
  }
  
  scan(document) {
    throw new Error("Method 'scan()' must be implemented");
  }
  
  fax(document) {
    throw new Error("Method 'fax()' must be implemented");
  }
  
  copy(document) {
    throw new Error("Method 'copy()' must be implemented");
  }
}

// All-in-one machine that can do everything
class AllInOnePrinter extends Machine {
  print(document) {
    console.log(`Printing document: ${document}`);
  }
  
  scan(document) {
    console.log(`Scanning document: ${document}`);
  }
  
  fax(document) {
    console.log(`Faxing document: ${document}`);
  }
  
  copy(document) {
    console.log(`Copying document: ${document}`);
  }
}

// Old printer that can only print - forced to implement methods it doesn't support
class OldPrinter extends Machine {
  print(document) {
    console.log(`Printing document: ${document}`);
  }
  
  // Forced to implement methods it doesn't support
  scan(document) {
    throw new Error("This printer cannot scan!");
  }
  
  fax(document) {
    throw new Error("This printer cannot fax!");
  }
  
  copy(document) {
    throw new Error("This printer cannot copy!");
  }
}

// Usage
function processDocument(machine, document) {
  machine.print(document);
  
  // This will throw an error for OldPrinter
  try {
    machine.scan(document);
  } catch (error) {
    console.error(error.message);
  }
}

const modernMachine = new AllInOnePrinter();
const oldPrinter = new OldPrinter();

processDocument(modernMachine, "Report.pdf"); // Works fine
processDocument(oldPrinter, "Letter.pdf");    // Throws error
```

In this example, `OldPrinter` is forced to implement methods it doesn't support just to satisfy the `Machine` interface. This is a clear violation of ISP.

### Example 2: Applying ISP with Separated Interfaces

Let's refactor the example to follow ISP by breaking down the large interface into smaller ones:

```javascript
// Separate interfaces for different functionalities
class Printer {
  print(document) {
    throw new Error("Method 'print()' must be implemented");
  }
}

class Scanner {
  scan(document) {
    throw new Error("Method 'scan()' must be implemented");
  }
}

class FaxMachine {
  fax(document) {
    throw new Error("Method 'fax()' must be implemented");
  }
}

class Copier {
  copy(document) {
    throw new Error("Method 'copy()' must be implemented");
  }
}

// Old printer only implements what it can do
class OldPrinter extends Printer {
  print(document) {
    console.log(`Printing document: ${document}`);
  }
}

// Scanner only implements scanning
class DesktopScanner extends Scanner {
  scan(document) {
    console.log(`Scanning document: ${document}`);
  }
}

// All-in-one machine implements all interfaces
class AllInOneMachine extends Printer {
  constructor() {
    super();
    this.scanner = new DesktopScanner();
    this.faxMachine = new FaxMachine();
    this.copier = new Copier();
  }
  
  print(document) {
    console.log(`Printing document: ${document}`);
  }
  
  scan(document) {
    this.scanner.scan(document);
  }
  
  fax(document) {
    console.log(`Faxing document: ${document}`);
  }
  
  copy(document) {
    console.log(`Copying document: ${document}`);
  }
}

// Usage with flexible client functions
function printDocument(printer, document) {
  printer.print(document);
}

function scanDocument(scanner, document) {
  scanner.scan(document);
}

// Usage
const printer = new OldPrinter();
const scanner = new DesktopScanner();
const allInOne = new AllInOneMachine();

printDocument(printer, "Letter.pdf");  // Works fine
printDocument(allInOne, "Report.pdf"); // Works fine
scanDocument(scanner, "Photo.jpg");    // Works fine
scanDocument(allInOne, "Contract.pdf"); // Works fine
```

With this design, classes only implement the interfaces they actually support. Clients can work with the specific interfaces they need without knowing about other functionality.

### Example 3: Using Composition for Multiple Interfaces

Instead of using inheritance, we can use composition to implement multiple interfaces:

```javascript
// Define interfaces as classes with methods
class PrinterInterface {
  print(document) {
    throw new Error("Method 'print()' must be implemented");
  }
}

class ScannerInterface {
  scan(document) {
    throw new Error("Method 'scan()' must be implemented");
  }
}

class FaxInterface {
  fax(document) {
    throw new Error("Method 'fax()' must be implemented");
  }
}

class CopierInterface {
  copy(document) {
    throw new Error("Method 'copy()' must be implemented");
  }
}

// Implementation classes
class PrinterImplementation {
  print(document) {
    console.log(`Printing document: ${document}`);
  }
}

class ScannerImplementation {
  scan(document) {
    console.log(`Scanning document: ${document}`);
  }
}

class FaxImplementation {
  fax(document) {
    console.log(`Faxing document: ${document}`);
  }
}

class CopierImplementation {
  copy(document) {
    console.log(`Copying document: ${document}`);
  }
}

// A simple printer
class SimplePrinter {
  constructor() {
    this.printer = new PrinterImplementation();
  }
  
  print(document) {
    this.printer.print(document);
  }
}

// All-in-one machine using composition
class AllInOneDevice {
  constructor() {
    this.printer = new PrinterImplementation();
    this.scanner = new ScannerImplementation();
    this.fax = new FaxImplementation();
    this.copier = new CopierImplementation();
  }
  
  print(document) {
    this.printer.print(document);
  }
  
  scan(document) {
    this.scanner.scan(document);
  }
  
  fax(document) {
    this.fax.fax(document);
  }
  
  copy(document) {
    this.copier.copy(document);
  }
}

// Usage
function printDocument(printer, document) {
  // Only requires the print method
  printer.print(document);
}

const simplePrinter = new SimplePrinter();
const allInOne = new AllInOneDevice();

printDocument(simplePrinter, "Letter.pdf");
printDocument(allInOne, "Report.pdf");
```

This composition-based approach provides more flexibility than inheritance and still respects ISP by allowing clients to work with specific interfaces.

### Example 4: ISP with Events and Callbacks

ISP also applies to event handlers and callbacks in JavaScript:

```javascript
// Bad: One large event handler interface
class BigEventHandler {
  handleMouseClick(event) {
    throw new Error("Method 'handleMouseClick()' must be implemented");
  }
  
  handleKeyPress(event) {
    throw new Error("Method 'handleKeyPress()' must be implemented");
  }
  
  handleWindowResize(event) {
    throw new Error("Method 'handleWindowResize()' must be implemented");
  }
  
  handleNetworkChange(event) {
    throw new Error("Method 'handleNetworkChange()' must be implemented");
  }
}

// Client that only needs mouse clicks, but has to implement everything
class ClickCounter extends BigEventHandler {
  constructor() {
    super();
    this.count = 0;
  }
  
  handleMouseClick(event) {
    this.count++;
    console.log(`Click count: ${this.count}`);
  }
  
  // Forced to implement unused methods
  handleKeyPress(event) {}
  handleWindowResize(event) {}
  handleNetworkChange(event) {}
}

// Better: Separate event handlers
class ClickHandler {
  handleClick(event) {
    throw new Error("Method 'handleClick()' must be implemented");
  }
}

class KeyHandler {
  handleKeyPress(event) {
    throw new Error("Method 'handleKeyPress()' must be implemented");
  }
}

class ResizeHandler {
  handleResize(event) {
    throw new Error("Method 'handleResize()' must be implemented");
  }
}

class NetworkHandler {
  handleNetworkChange(event) {
    throw new Error("Method 'handleNetworkChange()' must be implemented");
  }
}

// Client that only implements what it needs
class BetterClickCounter extends ClickHandler {
  constructor() {
    super();
    this.count = 0;
  }
  
  handleClick(event) {
    this.count++;
    console.log(`Click count: ${this.count}`);
  }
}

// Event system that respects ISP
class EventSystem {
  constructor() {
    this.clickHandlers = [];
    this.keyHandlers = [];
    this.resizeHandlers = [];
    this.networkHandlers = [];
  }
  
  registerClickHandler(handler) {
    this.clickHandlers.push(handler);
  }
  
  registerKeyHandler(handler) {
    this.keyHandlers.push(handler);
  }
  
  registerResizeHandler(handler) {
    this.resizeHandlers.push(handler);
  }
  
  registerNetworkHandler(handler) {
    this.networkHandlers.push(handler);
  }
  
  simulateClick(event) {
    this.clickHandlers.forEach(handler => handler.handleClick(event));
  }
  
  simulateKeyPress(event) {
    this.keyHandlers.forEach(handler => handler.handleKeyPress(event));
  }
  
  simulateResize(event) {
    this.resizeHandlers.forEach(handler => handler.handleResize(event));
  }
  
  simulateNetworkChange(event) {
    this.networkHandlers.forEach(handler => handler.handleNetworkChange(event));
  }
}

// Usage
const eventSystem = new EventSystem();
const clickCounter = new BetterClickCounter();

eventSystem.registerClickHandler(clickCounter);
eventSystem.simulateClick({ type: 'click', target: 'button' });
```

### Example 5: ISP with Function Parameters

ISP also applies to functions and their parameters:

```javascript
// Bad: Function expecting a large configuration object
function renderUserProfile(config) {
  console.log(`Name: ${config.name}`);
  console.log(`Email: ${config.email}`);
  console.log(`Age: ${config.age}`);
  console.log(`Address: ${config.address}`);
  console.log(`Phone: ${config.phone}`);
  console.log(`Subscription: ${config.subscription}`);
  console.log(`Payment Method: ${config.paymentMethod}`);
  // ...many more fields
}

// Usage forces providing all fields, even unused ones
renderUserProfile({
  name: "John Doe",
  email: "john@example.com",
  age: 30,
  address: "123 Main St",
  phone: "555-1234",
  subscription: "Premium",
  paymentMethod: "Credit Card"
});

// Better: Function with focused parameter objects
function renderUserBasicInfo({ name, email, age }) {
  console.log(`Name: ${name}`);
  console.log(`Email: ${email}`);
  console.log(`Age: ${age}`);
}

function renderUserContactInfo({ address, phone }) {
  console.log(`Address: ${address}`);
  console.log(`Phone: ${phone}`);
}

function renderUserSubscriptionInfo({ subscription, paymentMethod }) {
  console.log(`Subscription: ${subscription}`);
  console.log(`Payment Method: ${paymentMethod}`);
}

// Full function that uses specialized functions internally
function renderFullUserProfile(user) {
  renderUserBasicInfo(user);
  renderUserContactInfo(user);
  renderUserSubscriptionInfo(user);
}

// Usage now supports partial information
renderUserBasicInfo({
  name: "John Doe",
  email: "john@example.com",
  age: 30
});

// Or full information
const user = {
  name: "John Doe",
  email: "john@example.com",
  age: 30,
  address: "123 Main St",
  phone: "555-1234",
  subscription: "Premium",
  paymentMethod: "Credit Card"
};

renderFullUserProfile(user);
```

### Example 6: ISP in React Components

ISP is particularly important in React components:

```javascript
// Bad: One component that handles too many responsibilities
class UserDashboard extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      posts: [],
      friends: [],
      messages: [],
      notifications: [],
      settings: {}
    };
  }
  
  componentDidMount() {
    this.fetchUserData();
    this.fetchUserPosts();
    this.fetchUserFriends();
    this.fetchUserMessages();
    this.fetchUserNotifications();
    this.fetchUserSettings();
  }
  
  fetchUserData() { /* ... */ }
  fetchUserPosts() { /* ... */ }
  fetchUserFriends() { /* ... */ }
  fetchUserMessages() { /* ... */ }
  fetchUserNotifications() { /* ... */ }
  fetchUserSettings() { /* ... */ }
  
  renderProfile() { /* ... */ }
  renderPosts() { /* ... */ }
  renderFriends() { /* ... */ }
  renderMessages() { /* ... */ }
  renderNotifications() { /* ... */ }
  renderSettings() { /* ... */ }
  
  render() {
    return (
      <div>
        {this.renderProfile()}
        {this.renderPosts()}
        {this.renderFriends()}
        {this.renderMessages()}
        {this.renderNotifications()}
        {this.renderSettings()}
      </div>
    );
  }
}

// Better: Separate components with focused responsibilities
function UserProfile({ user }) {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.bio}</p>
    </div>
  );
}

function UserPosts({ posts }) {
  return (
    <div>
      <h2>Posts</h2>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}

function UserFriends({ friends }) {
  return (
    <div>
      <h2>Friends</h2>
      <ul>
        {friends.map(friend => (
          <li key={friend.id}>{friend.name}</li>
        ))}
      </ul>
    </div>
  );
}

// Main component that composes the others
function BetterUserDashboard() {
  const [user, setUser] = React.useState(null);
  const [posts, setPosts] = React.useState([]);
  const [friends, setFriends] = React.useState([]);
  
  React.useEffect(() => {
    // Fetch only what this component needs
    fetchUser().then(setUser);
    fetchPosts().then(setPosts);
    fetchFriends().then(setFriends);
  }, []);
  
  if (!user) return <div>Loading...</div>;
  
  return (
    <div>
      <UserProfile user={user} />
      <UserPosts posts={posts} />
      <UserFriends friends={friends} />
    </div>
  );
}

// Usage
function App() {
  return (
    <div>
      <BetterUserDashboard />
      
      {/* We can also use the components individually */}
      <UserProfile user={{ name: "Jane Doe", bio: "Software Engineer" }} />
    </div>
  );
}
```

### Example 7: Real-World Example - User Authentication System

Let's look at a more complex real-world example involving user authentication:

```javascript
// Bad: One large authentication service with too many responsibilities
class AuthenticationService {
  constructor() {
    this.currentUser = null;
  }
  
  login(username, password) {
    console.log(`Logging in ${username}`);
    this.currentUser = { username };
    return true;
  }
  
  logout() {
    console.log("Logging out");
    this.currentUser = null;
  }
  
  register(username, password, email) {
    console.log(`Registering user ${username}`);
    return { username, email };
  }
  
  resetPassword(email) {
    console.log(`Sending password reset email to ${email}`);
  }
  
  verifyEmail(token) {
    console.log(`Verifying email with token ${token}`);
  }
  
  getProfile() {
    return this.currentUser;
  }
  
  updateProfile(data) {
    console.log(`Updating profile for ${this.currentUser.username}`);
    Object.assign(this.currentUser, data);
  }
  
  checkPermission(permission) {
    console.log(`Checking permission ${permission}`);
    return true;
  }
  
  // ...many more methods
}

// Usage forces clients to depend on the entire service
const authService = new AuthenticationService();
authService.login("johndoe", "password123");
authService.checkPermission("admin");

// Better: Separated services with focused responsibilities
// Authentication service
class BetterAuthService {
  constructor() {
    this.currentUser = null;
  }
  
  login(username, password) {
    console.log(`Logging in ${username}`);
    this.currentUser = { username };
    return true;
  }
  
  logout() {
    console.log("Logging out");
    this.currentUser = null;
  }
  
  getCurrentUser() {
    return this.currentUser;
  }
}

// User registration service
class UserRegistrationService {
  register(username, password, email) {
    console.log(`Registering user ${username}`);
    return { username, email };
  }
  
  verifyEmail(token) {
    console.log(`Verifying email with token ${token}`);
  }
}

// Password management service
class PasswordService {
  resetPassword(email) {
    console.log(`Sending password reset email to ${email}`);
  }
  
  changePassword(username, oldPassword, newPassword) {
    console.log(`Changing password for ${username}`);
    return true;
  }
}

// User profile service
class UserProfileService {
  constructor(authService) {
    this.authService = authService;
  }
  
  getProfile() {
    return this.authService.getCurrentUser();
  }
  
  updateProfile(data) {
    const user = this.authService.getCurrentUser();
    if (!user) throw new Error("No user logged in");
    
    console.log(`Updating profile for ${user.username}`);
    Object.assign(user, data);
  }
}

// Permission service
class PermissionService {
  constructor(authService) {
    this.authService = authService;
  }
  
  checkPermission(permission) {
    const user = this.authService.getCurrentUser();
    if (!user) return false;
    
    console.log(`Checking permission ${permission} for ${user.username}`);
    return true; // Simplified
  }
}

// Usage allows clients to depend only on the services they need
const authService = new BetterAuthService();
const registrationService = new UserRegistrationService();
const passwordService = new PasswordService();
const profileService = new UserProfileService(authService);
const permissionService = new PermissionService(authService);

// Login component only needs auth service
function LoginForm() {
  return {
    handleSubmit(username, password) {
      return authService.login(username, password);
    }
  };
}

// Registration component only needs registration service
function RegistrationForm() {
  return {
    handleSubmit(username, password, email) {
      return registrationService.register(username, password, email);
    }
  };
}

// Profile component only needs profile service
function ProfileEditor() {
  return {
    loadProfile() {
      return profileService.getProfile();
    },
    updateProfile(data) {
      return profileService.updateProfile(data);
    }
  };
}
```

## Techniques for Applying ISP in JavaScript

### 1. Use Composition Over Inheritance

Instead of inheriting from a large interface, compose functionality from smaller interfaces:

```javascript
// Instead of this:
class AllInOne extends PrinterScannerFaxCopier { /* ... */ }

// Do this:
class AllInOne {
  constructor() {
    this.printer = new Printer();
    this.scanner = new Scanner();
    this.fax = new Fax();
    this.copier = new Copier();
  }
  
  print(document) {
    this.printer.print(document);
  }
  
  // ... other methods delegating to the appropriate component
}
```

### 2. Function Interface Segregation

Break large function interfaces into smaller, more focused ones:

```javascript
// Instead of this:
function processOrder(order, user, payment, shipping, inventory) {
  // Many parameters that might not all be used
}

// Do this:
function validateOrder(order) { /* ... */ }
function processPayment(order, payment) { /* ... */ }
function arrangeShipping(order, shipping) { /* ... */ }
function updateInventory(order, inventory) { /* ... */ }

function processOrder(order) {
  validateOrder(order);
  processPayment(order, order.payment);
  arrangeShipping(order, order.shipping);
  updateInventory(order, order.items);
}
```

### 3. Use Optional Parameters and Destructuring

Make interfaces more flexible with optional parameters and destructuring:

```javascript
// Instead of requiring all fields:
function createUser(name, email, age, address, phone) {
  // All parameters required
}

// Do this:
function createUser({ name, email, age = null, address = null, phone = null }) {
  // Only name and email are required
}

// Usage
createUser({ name: "John", email: "john@example.com" });
```

### 4. Adapter Pattern

Use adapters to convert between different interfaces:

```javascript
// Third-party library with a complex interface
class ThirdPartyPrinter {
  initialize() { /* ... */ }
  setPageSize(width, height) { /* ... */ }
  setColorMode(mode) { /* ... */ }
  output(content) { /* ... */ }
  finalize() { /* ... */ }
}

// Simple adapter that implements our simpler interface
class PrinterAdapter {
  constructor(thirdPartyPrinter) {
    this.printer = thirdPartyPrinter;
  }
  
  print(document) {
    this.printer.initialize();
    this.printer.setPageSize(8.5, 11);
    this.printer.setColorMode('color');
    this.printer.output(document);
    this.printer.finalize();
  }
}

// Client code uses the simple interface
function printDocument(printer, document) {
  printer.print(document);
}

const thirdPartyPrinter = new ThirdPartyPrinter();
const adapter = new PrinterAdapter(thirdPartyPrinter);

printDocument(adapter, "Report.pdf");
```

### 5. Role Interfaces

Create interfaces based on client roles or use cases:

```javascript
// User roles
class AdminUser {
  manageUsers() { /* ... */ }
  configureSystem() { /* ... */ }
}

class RegularUser {
  viewContent() { /* ... */ }
  updateProfile() { /* ... */ }
}

class ContentCreator {
  createContent() { /* ... */ }
  editContent() { /* ... */ }
}

// A user class that implements multiple roles
class User {
  constructor(roles = []) {
    this.roles = roles;
  }
  
  // Admin methods
  manageUsers() {
    if (!this.hasRole('admin')) throw new Error("Unauthorized");
    console.log("Managing users");
  }
  
  configureSystem() {
    if (!this.hasRole('admin')) throw new Error("Unauthorized");
    console.log("Configuring system");
  }
  
  // Regular user methods
  viewContent() {
    console.log("Viewing content");
  }
  
  updateProfile() {
    console.log("Updating profile");
  }
  
  // Content creator methods
  createContent() {
    if (!this.hasRole('creator')) throw new Error("Unauthorized");
    console.log("Creating content");
  }
  
  editContent() {
    if (!this.hasRole('creator')) throw new Error("Unauthorized");
    console.log("Editing content");
  }
  
  hasRole(role) {
    return this.roles.includes(role);
  }
}

// Client code that only knows about the admin interface
function adminPanel(admin) {
  admin.manageUsers();
  admin.configureSystem();
}

// Usage
const adminUser = new User(['admin']);
const creatorUser = new User(['creator']);
const regularUser = new User();

adminPanel(adminUser); // Works
try {
  adminPanel(regularUser); // Throws "Unauthorized"
} catch (error) {
  console.error(error.message);
}
```

## Common Challenges and Solutions

### 1. Retrofitting Existing Code

It can be challenging to apply ISP to existing code, especially if it's organized around large interfaces.

**Solution**: Use the Adapter pattern to create segregated interfaces that wrap the existing interfaces. Then gradually refactor the existing code to use the new interfaces.

### 2. Identifying the Right Granularity

It's not always clear how small interfaces should be. Too small and you have too many interfaces; too large and you violate ISP.

**Solution**: Let client usage guide your decisions. If clients consistently use only a subset of methods together, that subset might make a good interface.

### 3. Interface Evolution

As requirements change, interfaces need to evolve, which can lead to "interface pollution."

**Solution**: Favor composition over inheritance and use event systems or plugins that allow for dynamic extension without changing existing interfaces.

## Real-World Benefits of ISP

- **Improved maintainability**: Changes to one interface affect fewer clients
- **Better testability**: Smaller interfaces are easier to mock
- **Enhanced reusability**: Focused interfaces can be reused in more contexts
- **Reduced coupling**: Clients depend only on what they need
- **Clearer code organization**: Interface boundaries reflect natural divisions in the problem domain

## When to Be Flexible with ISP

While ISP is valuable, there are times when strict adherence isn't practical:

- **Simple applications**: For small applications, the overhead of many small interfaces might not be justified
- **Stable domains**: In domains that are well-understood and rarely change, the benefits of ISP might be less significant
- **Performance-critical code**: Too much indirection can impact performance in critical parts of the system

## Design Patterns That Help with ISP

Several design patterns can help implement ISP:

### 1. Facade Pattern

Create a simplified interface over a complex subsystem:

```javascript
// Complex subsystem
class CPU {
  freeze() { console.log("CPU freezing"); }
  jump(position) { console.log(`CPU jumping to ${position}`); }
  execute() { console.log("CPU executing"); }
}

class Memory {
  load(position, data) { console.log(`Memory loading ${data} at position ${position}`); }
}

class HardDrive {
  read(sector, size) { console.log(`HardDrive reading ${size} bytes from sector ${sector}`); }
}

// Facade providing a simplified interface
class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    this.cpu.freeze();
    this.memory.load(0, "boot data");
    this.cpu.jump(0);
    this.cpu.execute();
  }
}

// Client code
const computer = new ComputerFacade();
computer.start();
```

### 2. Adapter Pattern

Convert one interface to another:

```javascript
// External service with its own interface
class ExternalPaymentGateway {
  makePayment(amount, currency, cardDetails) {
    console.log(`Processing payment of ${amount} ${currency}`);
    return { transactionId: "tx123", status: "success" };
  }
  
  refundPayment(transactionId) {
    console.log(`Refunding transaction ${transactionId}`);
    return { status: "refunded" };
  }
}

// Our application's payment interface
class PaymentProcessor {
  processPayment(paymentInfo) {
    throw new Error("Method 'processPayment()' must be implemented");
  }
  
  refund(paymentId) {
    throw new Error("Method 'refund()' must be implemented");
  }
}

// Adapter making the external gateway conform to our interface
class PaymentGatewayAdapter extends PaymentProcessor {
  constructor(gateway) {
    super();
    this.gateway = gateway;
  }
  
  processPayment(paymentInfo) {
    const { amount, currency, cardNumber, expiryDate, cvv } = paymentInfo;
    
    const result = this.gateway.makePayment(
      amount,
      currency,
      { cardNumber, expiryDate, cvv }
    );
    
    return {
      paymentId: result.transactionId,
      success: result.status === "success"
    };
  }
  
  refund(paymentId) {
    const result = this.gateway.refundPayment(paymentId);
    return {
      success: result.status === "refunded"
    };
  }
}

// Client code using our interface
function checkout(paymentProcessor, cart) {
  const total = cart.items.reduce((sum, item) => sum + item.price, 0);
  
  const paymentResult = paymentProcessor.processPayment({
    amount: total,
    currency: "USD",
    cardNumber: cart.paymentDetails.cardNumber,
    expiryDate: cart.paymentDetails.expiryDate,
    cvv: cart.paymentDetails.cvv
  });
  
  if (paymentResult.success) {
    console.log(`Payment successful. Transaction ID: ${paymentResult.paymentId}`);
    return { success: true, transactionId: paymentResult.paymentId };
  } else {
    console.log("Payment failed");
    return { success: false };
  }
}

// Usage
const externalGateway = new ExternalPaymentGateway();
const adapter = new PaymentGatewayAdapter(externalGateway);

const cart = {
  items: [
    { name: "Product 1", price: 50 },
    { name: "Product 2", price: 30 }
  ],
  paymentDetails: {
    cardNumber: "4111111111111111",
    expiryDate: "12/25",
    cvv: "123"
  }
};

checkout(adapter, cart);
```

### 3. Decorator Pattern

Add responsibilities to objects dynamically without modifying their structure:

```javascript
// Base component interface
class DataSource {
  readData() {
    throw new Error("Method 'readData()' must be implemented");
  }
  
  writeData(data) {
    throw new Error("Method 'writeData()' must be implemented");
  }
}

// Concrete component
class FileDataSource extends DataSource {
  constructor(filename) {
    super();
    this.filename = filename;
  }
  
  readData() {
    console.log(`Reading data from file: ${this.filename}`);
    return "Some data from file";
  }
  
  writeData(data) {
    console.log(`Writing data to file: ${this.filename}`);
    console.log(`Data: ${data}`);
  }
}

// Base decorator
class DataSourceDecorator extends DataSource {
  constructor(source) {
    super();
    this.wrappee = source;
  }
  
  readData() {
    return this.wrappee.readData();
  }
  
  writeData(data) {
    this.wrappee.writeData(data);
  }
}

// Specific decorators with focused responsibilities
class EncryptionDecorator extends DataSourceDecorator {
  readData() {
    const encryptedData = this.wrappee.readData();
    return this.decrypt(encryptedData);
  }
  
  writeData(data) {
    const encryptedData = this.encrypt(data);
    this.wrappee.writeData(encryptedData);
  }
  
  encrypt(data) {
    console.log("Encrypting data");
    return `ENCRYPTED: ${data}`;
  }
  
  decrypt(data) {
    console.log("Decrypting data");
    return data.replace("ENCRYPTED: ", "");
  }
}

class CompressionDecorator extends DataSourceDecorator {
  readData() {
    const compressedData = this.wrappee.readData();
    return this.decompress(compressedData);
  }
  
  writeData(data) {
    const compressedData = this.compress(data);
    this.wrappee.writeData(compressedData);
  }
  
  compress(data) {
    console.log("Compressing data");
    return `COMPRESSED: ${data}`;
  }
  
  decompress(data) {
    console.log("Decompressing data");
    return data.replace("COMPRESSED: ", "");
  }
}

// Client code that only needs encryption
function storeEncryptedData(source, data) {
  const encryptedSource = new EncryptionDecorator(source);
  encryptedSource.writeData(data);
}

// Client code that only needs compression
function storeCompressedData(source, data) {
  const compressedSource = new CompressionDecorator(source);
  compressedSource.writeData(data);
}

// Client code that needs both
function storeSecureAndEfficientData(source, data) {
  // Compose decorators
  const compressedSource = new CompressionDecorator(source);
  const encryptedAndCompressedSource = new EncryptionDecorator(compressedSource);
  encryptedAndCompressedSource.writeData(data);
}

// Usage
const fileSource = new FileDataSource("data.txt");
storeEncryptedData(fileSource, "Sensitive data");
storeCompressedData(fileSource, "Large data");
storeSecureAndEfficientData(fileSource, "Sensitive and large data");
```

### 4. Bridge Pattern

Separate an abstraction from its implementation so both can vary independently:

```javascript
// Implementation interface with focused methods
class DrawingAPI {
  drawCircle(x, y, radius) {
    throw new Error("Method 'drawCircle()' must be implemented");
  }
  
  drawRectangle(x, y, width, height) {
    throw new Error("Method 'drawRectangle()' must be implemented");
  }
}

// Concrete implementations
class SVGDrawingAPI extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`SVG: Drawing circle at (${x},${y}) with radius ${radius}`);
  }
  
  drawRectangle(x, y, width, height) {
    console.log(`SVG: Drawing rectangle at (${x},${y}) with width ${width} and height ${height}`);
  }
}

class CanvasDrawingAPI extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`Canvas: Drawing circle at (${x},${y}) with radius ${radius}`);
  }
  
  drawRectangle(x, y, width, height) {
    console.log(`Canvas: Drawing rectangle at (${x},${y}) with width ${width} and height ${height}`);
  }
}

// Abstraction
class Shape {
  constructor(drawingAPI) {
    this.drawingAPI = drawingAPI;
  }
  
  draw() {
    throw new Error("Method 'draw()' must be implemented");
  }
  
  resize(factor) {
    throw new Error("Method 'resize()' must be implemented");
  }
}

// Refined abstractions
class Circle extends Shape {
  constructor(x, y, radius, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.radius = radius;
  }
  
  draw() {
    this.drawingAPI.drawCircle(this.x, this.y, this.radius);
  }
  
  resize(factor) {
    this.radius *= factor;
  }
}

class Rectangle extends Shape {
  constructor(x, y, width, height, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  
  draw() {
    this.drawingAPI.drawRectangle(this.x, this.y, this.width, this.height);
  }
  
  resize(factor) {
    this.width *= factor;
    this.height *= factor;
  }
}

// Client code
const svgAPI = new SVGDrawingAPI();
const canvasAPI = new CanvasDrawingAPI();

const circleSVG = new Circle(10, 10, 5, svgAPI);
const rectangleCanvas = new Rectangle(0, 0, 10, 20, canvasAPI);

circleSVG.draw();
rectangleCanvas.draw();

circleSVG.resize(2);
rectangleCanvas.resize(0.5);

circleSVG.draw();
rectangleCanvas.draw();
```

### 5. Command Pattern with Interface Segregation

Encapsulate a request as an object, allowing for parameterized clients:

```javascript
// Command interfaces segmented by responsibility
class Executable {
  execute() {
    throw new Error("Method 'execute()' must be implemented");
  }
}

class Undoable extends Executable {
  undo() {
    throw new Error("Method 'undo()' must be implemented");
  }
}

class Loggable {
  getLogMessage() {
    throw new Error("Method 'getLogMessage()' must be implemented");
  }
}

// Basic command that can only be executed
class SimpleCommand extends Executable {
  constructor(receiver, action) {
    super();
    this.receiver = receiver;
    this.action = action;
  }
  
  execute() {
    this.receiver[this.action]();
  }
}

// Command that can be executed and undone
class UndoableCommand extends Undoable {
  constructor(receiver, doAction, undoAction) {
    super();
    this.receiver = receiver;
    this.doAction = doAction;
    this.undoAction = undoAction;
  }
  
  execute() {
    this.receiver[this.doAction]();
  }
  
  undo() {
    this.receiver[this.undoAction]();
  }
}

// Command that can be executed and logged
class LoggableCommand extends Executable {
  constructor(receiver, action, description) {
    super();
    this.receiver = receiver;
    this.action = action;
    this.description = description;
  }
  
  execute() {
    console.log(this.getLogMessage());
    this.receiver[this.action]();
  }
  
  getLogMessage() {
    return `Executing command: ${this.description}`;
  }
}

// Full-featured command that implements all interfaces
class ComplexCommand extends Undoable {
  constructor(receiver, doAction, undoAction, description) {
    super();
    this.receiver = receiver;
    this.doAction = doAction;
    this.undoAction = undoAction;
    this.description = description;
  }
  
  execute() {
    console.log(this.getLogMessage());
    this.receiver[this.doAction]();
  }
  
  undo() {
    console.log(`Undoing: ${this.description}`);
    this.receiver[this.undoAction]();
  }
  
  getLogMessage() {
    return `Executing command: ${this.description}`;
  }
}

// Receiver
class Light {
  turnOn() {
    console.log("Light turned on");
  }
  
  turnOff() {
    console.log("Light turned off");
  }
}

// Client code with different capabilities
function executeCommand(command) {
  command.execute();
}

function executeAndUndoCommand(command) {
  command.execute();
  // Do something else
  command.undo();
}

function logAndExecuteCommand(command) {
  console.log(command.getLogMessage());
  command.execute();
}

// Usage
const light = new Light();

// Client that only needs execution
const turnOnCommand = new SimpleCommand(light, "turnOn");
executeCommand(turnOnCommand);

// Client that needs execution and undo
const toggleCommand = new UndoableCommand(light, "turnOn", "turnOff");
executeAndUndoCommand(toggleCommand);

// Client that needs execution and logging
const loggedOnCommand = new LoggableCommand(light, "turnOn", "Turn on the light");
executeCommand(loggedOnCommand);

// Client that needs everything
const complexCommand = new ComplexCommand(light, "turnOn", "turnOff", "Toggle the light");
executeAndUndoCommand(complexCommand);
```

### 6. Proxy Pattern with Limited Interface Exposure

Control access to an object by providing a surrogate:

```javascript
// Full service interface
class DatabaseService {
  connect() {
    console.log("Connecting to database");
  }
  
  disconnect() {
    console.log("Disconnecting from database");
  }
  
  query(sql) {
    console.log(`Executing query: ${sql}`);
    return [{ id: 1, name: "John" }];
  }
  
  update(sql) {
    console.log(`Executing update: ${sql}`);
    return true;
  }
  
  delete(sql) {
    console.log(`Executing delete: ${sql}`);
    return true;
  }
  
  backup() {
    console.log("Creating database backup");
  }
  
  restore(backupId) {
    console.log(`Restoring database from backup: ${backupId}`);
  }
}

// Read-only interface
class ReadOnlyDatabaseProxy {
  constructor(service) {
    this.service = service;
    this.connected = false;
  }
  
  connect() {
    if (!this.connected) {
      this.service.connect();
      this.connected = true;
    }
  }
  
  disconnect() {
    if (this.connected) {
      this.service.disconnect();
      this.connected = false;
    }
  }
  
  query(sql) {
    if (!this.connected) {
      this.connect();
    }
    
    if (sql.toLowerCase().includes('select')) {
      return this.service.query(sql);
    } else {
      throw new Error("Access denied: Read-only proxy cannot execute non-SELECT queries");
    }
  }
}

// Admin interface
class AdminDatabaseProxy {
  constructor(service, credentials) {
    this.service = service;
    this.credentials = credentials;
    this.connected = false;
  }
  
  authenticate() {
    // Simplified authentication
    return this.credentials.username === "admin" && this.credentials.password === "adminpass";
  }
  
  connect() {
    if (!this.connected) {
      if (this.authenticate()) {
        this.service.connect();
        this.connected = true;
      } else {
        throw new Error("Authentication failed");
      }
    }
  }
  
  disconnect() {
    if (this.connected) {
      this.service.disconnect();
      this.connected = false;
    }
  }
  
  query(sql) {
    this.connect();
    return this.service.query(sql);
  }
  
  update(sql) {
    this.connect();
    return this.service.update(sql);
  }
  
  delete(sql) {
    this.connect();
    return this.service.delete(sql);
  }
  
  backup() {
    this.connect();
    return this.service.backup();
  }
  
  restore(backupId) {
    this.connect();
    return this.service.restore(backupId);
  }
}

// Client code for regular users (read-only)
function generateReport(database) {
  const users = database.query("SELECT * FROM users");
  console.log("Generating report:", users);
}

// Client code for admins
function performMaintenance(database) {
  database.backup();
  database.update("UPDATE system_settings SET value = 'new value' WHERE key = 'maintenance_mode'");
}

// Usage
const realService = new DatabaseService();

// Read-only client
const readOnlyProxy = new ReadOnlyDatabaseProxy(realService);
generateReport(readOnlyProxy);

try {
  readOnlyProxy.update("UPDATE users SET active = false WHERE id = 1");
} catch (error) {
  console.error(error.message);
}

// Admin client
const adminProxy = new AdminDatabaseProxy(realService, { username: "admin", password: "adminpass" });
generateReport(adminProxy);
performMaintenance(adminProxy);
```

### 7. Mediator Pattern

Define an object that encapsulates how a set of objects interact, promoting loose coupling:

```javascript
// Focused interfaces for different components
class UserInterface {
  notify(event) {
    throw new Error("Method 'notify()' must be implemented");
  }
}

class NetworkInterface {
  send(data) {
    throw new Error("Method 'send()' must be implemented");
  }
  
  receive(callback) {
    throw new Error("Method 'receive()' must be implemented");
  }
}

class StorageInterface {
  save(key, data) {
    throw new Error("Method 'save()' must be implemented");
  }
  
  load(key) {
    throw new Error("Method 'load()' must be implemented");
  }
}

// Component implementations
class UserComponent extends UserInterface {
  constructor(mediator) {
    super();
    this.mediator = mediator;
  }
  
  notify(event) {
    console.log(`UserComponent received notification: ${event}`);
  }
  
  userAction(action) {
    console.log(`User performed action: ${action}`);
    this.mediator.userDidAction(action);
  }
}

class NetworkComponent extends NetworkInterface {
  constructor(mediator) {
    super();
    this.mediator = mediator;
  }
  
  send(data) {
    console.log(`Sending data: ${JSON.stringify(data)}`);
    // Simulate network request
    setTimeout(() => {
      this.mediator.networkDidReceiveResponse({ status: "success", data: "Response data" });
    }, 1000);
  }
  
  receive(callback) {
    console.log("Setting up network listener");
    // Implementation of receiving data
  }
}

class StorageComponent extends StorageInterface {
  constructor(mediator) {
    super();
    this.mediator = mediator;
    this.data = new Map();
  }
  
  save(key, data) {
    console.log(`Saving data for key: ${key}`);
    this.data.set(key, data);
    this.mediator.storageDidSave(key);
  }
  
  load(key) {
    console.log(`Loading data for key: ${key}`);
    const data = this.data.get(key);
    this.mediator.storageDidLoad(key, data);
    return data;
  }
}

// Mediator that connects the components
class AppMediator {
  constructor() {
    this.userComponent = new UserComponent(this);
    this.networkComponent = new NetworkComponent(this);
    this.storageComponent = new StorageComponent(this);
  }
  
  userDidAction(action) {
    console.log(`Mediator received user action: ${action}`);
    
    if (action === "refresh") {
      this.networkComponent.send({ type: "getData" });
    } else if (action === "save") {
      this.storageComponent.save("user-data", { name: "John", preferences: { theme: "dark" } });
    }
  }
  
  networkDidReceiveResponse(response) {
    console.log(`Mediator received network response: ${JSON.stringify(response)}`);
    
    if (response.status === "success") {
      this.storageComponent.save("api-data", response.data);
      this.userComponent.notify("Data successfully loaded");
    } else {
      this.userComponent.notify("Error loading data");
    }
  }
  
  storageDidSave(key) {
    console.log(`Mediator: storage saved key: ${key}`);
    this.userComponent.notify(`Data saved for ${key}`);
  }
  
  storageDidLoad(key, data) {
    console.log(`Mediator: storage loaded key: ${key}`);
    if (data) {
      this.userComponent.notify(`Data loaded for ${key}`);
    } else {
      this.userComponent.notify(`No data found for ${key}`);
    }
  }
}

// Client code
const app = new AppMediator();

// User triggers an action
app.userComponent.userAction("refresh");
app.userComponent.userAction("save");

// Direct usage of individual components
const userData = app.storageComponent.load("user-data");
console.log("User data:", userData);
```

## When to Use Each Pattern

- **Facade Pattern**: When you need to provide a simplified interface to a complex subsystem, or when you want to decouple client code from subsystem components.

- **Adapter Pattern**: When you need to make classes with incompatible interfaces work together, or when integrating third-party code with specific interfaces.

- **Decorator Pattern**: When you need to add responsibilities to objects dynamically without affecting other objects, or when extension by subclassing is impractical.

- **Bridge Pattern**: When you want to avoid a permanent binding between abstraction and implementation, allowing them to vary independently.

- **Command Pattern**: When you want to parameterize objects with operations, support undoable operations, or implement callbacks.

- **Proxy Pattern**: When you need to control access to an object, providing only the interfaces that specific clients need.

- **Mediator Pattern**: When you want to reduce coupling between components by centralizing their interactions, or when component interactions become too complex.

## Conclusion

The Interface Segregation Principle encourages creating small, focused interfaces that are tailored to specific client needs. These design patterns provide practical ways to implement ISP in your JavaScript applications, helping you create more maintainable and flexible code.

By applying these patterns, you can:

1. Reduce coupling between components
2. Simplify interfaces for specific client needs
3. Make your code more modular and easier to maintain
4. Create systems that are easier to test and extend

Remember that design patterns are tools to help implement principles like ISP, not ends in themselves. Choose the pattern that best fits your specific requirements and constraints, and be mindful of the tradeoffs involved in each approach.