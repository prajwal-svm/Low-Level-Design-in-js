# Dependency Inversion Principle (DIP)

## What is the Dependency Inversion Principle?

The Dependency Inversion Principle states:

> A. High-level modules should not depend on low-level modules. Both should depend on abstractions.
> 
> B. Abstractions should not depend on details. Details should depend on abstractions.

In simpler terms, this principle encourages us to write code that depends on abstractions rather than concrete implementations. It inverts the traditional dependency flow, where high-level modules (which contain the complex business rules) often depend on low-level modules (which handle specific operations like data access or UI rendering).

Though JavaScript doesn't have formal interfaces or abstract classes like some other languages, we can still apply this principle through duck typing and dependency injection.

## Why is DIP Important?

1. **Decoupling**: Reduces tight coupling between components, making the system more modular
2. **Testability**: Makes it easier to test components in isolation by substituting dependencies
3. **Flexibility**: Enables swapping implementations without changing the code that uses them
4. **Stability**: High-level modules containing important business logic become insulated from changes in low-level modules
5. **Maintainability**: The system becomes easier to maintain as components have clearer boundaries

## DIP Violations: Signs and Symptoms

You might be violating DIP if:

- High-level business logic directly instantiates or depends on specific implementations
- Changing a low-level component requires changes to high-level components
- Testing requires complex setup or mocking of concrete dependencies
- Code contains many direct references to specific frameworks, databases, or third-party libraries
- You find it difficult to reuse code in different contexts due to hardcoded dependencies

## Examples of DIP in JavaScript

### Example 1: Basic DIP Violation

Let's start with an example that violates the Dependency Inversion Principle:

```javascript
// Low-level module (specific implementation)
class MySQLDatabase {
  constructor() {
    this.connected = false;
  }
  
  connect() {
    this.connected = true;
    console.log("Connected to MySQL database");
  }
  
  query(sql) {
    if (!this.connected) {
      throw new Error("Not connected to database");
    }
    console.log(`Executing query: ${sql}`);
    return [{ id: 1, name: "John" }, { id: 2, name: "Jane" }];
  }
  
  disconnect() {
    this.connected = false;
    console.log("Disconnected from MySQL database");
  }
}

// High-level module (depends directly on the low-level module)
class UserService {
  constructor() {
    this.database = new MySQLDatabase(); // Direct dependency on concrete implementation
  }
  
  getUsers() {
    this.database.connect();
    const users = this.database.query("SELECT * FROM users");
    this.database.disconnect();
    return users;
  }
  
  getUserById(id) {
    this.database.connect();
    const users = this.database.query(`SELECT * FROM users WHERE id = ${id}`);
    this.database.disconnect();
    return users[0];
  }
}

// Usage
const userService = new UserService();
const users = userService.getUsers();
console.log(users);
```

In this example, `UserService` (high-level module) directly depends on `MySQLDatabase` (low-level module). This violates DIP because the high-level module depends on a specific implementation detail, not an abstraction.

### Example 2: Applying DIP

Let's refactor the example to follow DIP:

```javascript
// Abstraction (interface) for a database
class Database {
  connect() {
    throw new Error("Method 'connect()' must be implemented");
  }
  
  query(sql) {
    throw new Error("Method 'query()' must be implemented");
  }
  
  disconnect() {
    throw new Error("Method 'disconnect()' must be implemented");
  }
}

// Low-level module implementing the abstraction
class MySQLDatabase extends Database {
  constructor() {
    super();
    this.connected = false;
  }
  
  connect() {
    this.connected = true;
    console.log("Connected to MySQL database");
  }
  
  query(sql) {
    if (!this.connected) {
      throw new Error("Not connected to database");
    }
    console.log(`Executing MySQL query: ${sql}`);
    return [{ id: 1, name: "John" }, { id: 2, name: "Jane" }];
  }
  
  disconnect() {
    this.connected = false;
    console.log("Disconnected from MySQL database");
  }
}

// Another implementation of the abstraction
class MongoDBDatabase extends Database {
  constructor() {
    super();
    this.connected = false;
  }
  
  connect() {
    this.connected = true;
    console.log("Connected to MongoDB database");
  }
  
  query(sql) {
    if (!this.connected) {
      throw new Error("Not connected to database");
    }
    console.log(`Translating SQL to MongoDB query: ${sql}`);
    return [{ id: 1, name: "John" }, { id: 2, name: "Jane" }];
  }
  
  disconnect() {
    this.connected = false;
    console.log("Disconnected from MongoDB database");
  }
}

// High-level module depends on abstraction
class UserService {
  constructor(database) {
    this.database = database; // Dependency injection
  }
  
  getUsers() {
    this.database.connect();
    const users = this.database.query("SELECT * FROM users");
    this.database.disconnect();
    return users;
  }
  
  getUserById(id) {
    this.database.connect();
    const users = this.database.query(`SELECT * FROM users WHERE id = ${id}`);
    this.database.disconnect();
    return users[0];
  }
}

// Usage
const mysqlDatabase = new MySQLDatabase();
const userServiceWithMySQL = new UserService(mysqlDatabase);
const usersFromMySQL = userServiceWithMySQL.getUsers();
console.log(usersFromMySQL);

const mongoDatabase = new MongoDBDatabase();
const userServiceWithMongo = new UserService(mongoDatabase);
const usersFromMongo = userServiceWithMongo.getUsers();
console.log(usersFromMongo);
```

In this refactored example, both `UserService` and the database implementations depend on the `Database` abstraction. `UserService` no longer depends directly on a specific database implementation.

### Example 3: DIP with Dependency Injection

Let's look at a more complex example with dependency injection:

```javascript
// Abstractions (interfaces)
class Logger {
  log(message) {
    throw new Error("Method 'log()' must be implemented");
  }
}

class PaymentGateway {
  processPayment(amount, currency, cardDetails) {
    throw new Error("Method 'processPayment()' must be implemented");
  }
}

class EmailService {
  sendEmail(to, subject, body) {
    throw new Error("Method 'sendEmail()' must be implemented");
  }
}

// Implementations
class ConsoleLogger extends Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class StripePaymentGateway extends PaymentGateway {
  processPayment(amount, currency, cardDetails) {
    console.log(`Processing Stripe payment of ${amount} ${currency}`);
    return { transactionId: `stripe-${Date.now()}`, status: "success" };
  }
}

class SendGridEmailService extends EmailService {
  sendEmail(to, subject, body) {
    console.log(`Sending email via SendGrid to ${to} with subject: ${subject}`);
    return true;
  }
}

// High-level module depending on abstractions
class OrderService {
  constructor(paymentGateway, logger, emailService) {
    this.paymentGateway = paymentGateway;
    this.logger = logger;
    this.emailService = emailService;
  }
  
  placeOrder(order) {
    this.logger.log(`Starting order processing for order #${order.id}`);
    
    try {
      const paymentResult = this.paymentGateway.processPayment(
        order.total,
        order.currency,
        order.paymentDetails
      );
      
      if (paymentResult.status === "success") {
        this.logger.log(`Payment successful for order #${order.id}`);
        
        // Process order...
        
        this.emailService.sendEmail(
          order.customerEmail,
          "Your order has been placed",
          `Thank you for your order #${order.id}`
        );
        
        return { success: true, orderId: order.id };
      } else {
        this.logger.log(`Payment failed for order #${order.id}`);
        return { success: false, error: "Payment failed" };
      }
    } catch (error) {
      this.logger.log(`Error processing order #${order.id}: ${error.message}`);
      return { success: false, error: error.message };
    }
  }
}

// Dependency container for managing dependencies
class DependencyContainer {
  constructor() {
    this.dependencies = new Map();
  }
  
  register(abstraction, implementation) {
    this.dependencies.set(abstraction.name, implementation);
  }
  
  resolve(abstraction) {
    const implementation = this.dependencies.get(abstraction.name);
    if (!implementation) {
      throw new Error(`No implementation registered for ${abstraction.name}`);
    }
    return implementation;
  }
}

// Set up the dependency container
const container = new DependencyContainer();
container.register(Logger, new ConsoleLogger());
container.register(PaymentGateway, new StripePaymentGateway());
container.register(EmailService, new SendGridEmailService());

// Create the OrderService with dependencies
const orderService = new OrderService(
  container.resolve(PaymentGateway),
  container.resolve(Logger),
  container.resolve(EmailService)
);

// Usage
const order = {
  id: "ORD-12345",
  total: 99.99,
  currency: "USD",
  customerEmail: "customer@example.com",
  paymentDetails: {
    cardNumber: "4111111111111111",
    expiryDate: "12/25",
    cvv: "123"
  }
};

const result = orderService.placeOrder(order);
console.log(result);
```

This example demonstrates DIP with a dependency container, which is a common pattern in larger applications. The high-level `OrderService` depends on abstractions, and the concrete implementations are provided through dependency injection.

### Example 4: DIP in Frontend Development (React)

DIP is also valuable in frontend development. Here's an example with React:

```javascript
// Abstraction for API client
class ApiClient {
  get(endpoint) {
    throw new Error("Method 'get()' must be implemented");
  }
  
  post(endpoint, data) {
    throw new Error("Method 'post()' must be implemented");
  }
}

// Implementation using fetch
class FetchApiClient extends ApiClient {
  constructor(baseUrl) {
    super();
    this.baseUrl = baseUrl;
  }
  
  async get(endpoint) {
    const response = await fetch(`${this.baseUrl}/${endpoint}`);
    return response.json();
  }
  
  async post(endpoint, data) {
    const response = await fetch(`${this.baseUrl}/${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

// Implementation using axios (a popular HTTP client)
class AxiosApiClient extends ApiClient {
  constructor(baseUrl) {
    super();
    this.baseUrl = baseUrl;
    this.axios = axios.create({
      baseURL: baseUrl
    });
  }
  
  async get(endpoint) {
    const response = await this.axios.get(endpoint);
    return response.data;
  }
  
  async post(endpoint, data) {
    const response = await this.axios.post(endpoint, data);
    return response.data;
  }
}

// React component that depends on the abstraction
function UserList({ apiClient }) {
  const [users, setUsers] = React.useState([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState(null);
  
  React.useEffect(() => {
    const fetchUsers = async () => {
      try {
        const data = await apiClient.get('users');
        setUsers(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    };
    
    fetchUsers();
  }, [apiClient]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h1>Users</h1>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

// Create the API client
const apiClient = new FetchApiClient('https://api.example.com');

// Usage
function App() {
  return (
    <div>
      <UserList apiClient={apiClient} />
    </div>
  );
}
```

This example demonstrates how DIP can be applied in React components. The `UserList` component depends on an abstraction (`ApiClient`) rather than a specific implementation, making it more reusable and easier to test.

### Example 5: Real-World Example - E-commerce Order Processing

Let's look at a more complex real-world example for an e-commerce application:

```javascript
// Abstractions
class InventoryService {
  checkAvailability(productId, quantity) {
    throw new Error("Method 'checkAvailability()' must be implemented");
  }
  
  reserveItems(productId, quantity) {
    throw new Error("Method 'reserveItems()' must be implemented");
  }
  
  releaseItems(productId, quantity) {
    throw new Error("Method 'releaseItems()' must be implemented");
  }
}

class PaymentProcessor {
  processPayment(orderId, amount, paymentMethod) {
    throw new Error("Method 'processPayment()' must be implemented");
  }
  
  refundPayment(transactionId, amount) {
    throw new Error("Method 'refundPayment()' must be implemented");
  }
}

class ShippingService {
  calculateShippingCost(address, items) {
    throw new Error("Method 'calculateShippingCost()' must be implemented");
  }
  
  createShippingLabel(orderId, address, items) {
    throw new Error("Method 'createShippingLabel()' must be implemented");
  }
}

class NotificationService {
  sendOrderConfirmation(orderId, customerEmail, orderDetails) {
    throw new Error("Method 'sendOrderConfirmation()' must be implemented");
  }
  
  sendShippingConfirmation(orderId, customerEmail, trackingNumber) {
    throw new Error("Method 'sendShippingConfirmation()' must be implemented");
  }
}

// Implementations
class WarehouseInventoryService extends InventoryService {
  constructor() {
    super();
    // In a real application, this would connect to a database
    this.inventory = new Map([
      [1, { name: "Product 1", quantity: 100 }],
      [2, { name: "Product 2", quantity: 50 }],
      [3, { name: "Product 3", quantity: 75 }]
    ]);
  }
  
  checkAvailability(productId, quantity) {
    const product = this.inventory.get(productId);
    if (!product) return false;
    return product.quantity >= quantity;
  }
  
  reserveItems(productId, quantity) {
    const product = this.inventory.get(productId);
    if (!product || product.quantity < quantity) return false;
    
    product.quantity -= quantity;
    this.inventory.set(productId, product);
    return true;
  }
  
  releaseItems(productId, quantity) {
    const product = this.inventory.get(productId);
    if (!product) return false;
    
    product.quantity += quantity;
    this.inventory.set(productId, product);
    return true;
  }
}

class StripePaymentProcessor extends PaymentProcessor {
  processPayment(orderId, amount, paymentMethod) {
    console.log(`Processing Stripe payment of $${amount} for order ${orderId}`);
    // In a real application, this would call the Stripe API
    return {
      success: true,
      transactionId: `stripe-${Date.now()}`,
      amount: amount,
      timestamp: new Date().toISOString()
    };
  }
  
  refundPayment(transactionId, amount) {
    console.log(`Refunding $${amount} for transaction ${transactionId}`);
    // In a real application, this would call the Stripe API
    return {
      success: true,
      refundId: `refund-${Date.now()}`,
      amount: amount,
      timestamp: new Date().toISOString()
    };
  }
}

class FedExShippingService extends ShippingService {
  calculateShippingCost(address, items) {
    // In a real application, this would call the FedEx API
    const baseRate = 10;
    const itemCount = items.reduce((total, item) => total + item.quantity, 0);
    return baseRate + (itemCount * 2);
  }
  
  createShippingLabel(orderId, address, items) {
    console.log(`Creating FedEx shipping label for order ${orderId} to ${address.city}`);
    // In a real application, this would call the FedEx API
    return {
      trackingNumber: `fedex-${Date.now()}`,
      estimatedDelivery: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString()
    };
  }
}

class EmailNotificationService extends NotificationService {
  sendOrderConfirmation(orderId, customerEmail, orderDetails) {
    console.log(`Sending order confirmation email to ${customerEmail} for order ${orderId}`);
    // In a real application, this would send an email
    return true;
  }
  
  sendShippingConfirmation(orderId, customerEmail, trackingNumber) {
    console.log(`Sending shipping confirmation email to ${customerEmail} for order ${orderId} with tracking number ${trackingNumber}`);
    // In a real application, this would send an email
    return true;
  }
}

// High-level module for order processing
class OrderProcessor {
  constructor(inventoryService, paymentProcessor, shippingService, notificationService) {
    this.inventoryService = inventoryService;
    this.paymentProcessor = paymentProcessor;
    this.shippingService = shippingService;
    this.notificationService = notificationService;
  }
  
  async processOrder(order) {
    console.log(`Processing order ${order.id}`);
    
    // Check inventory
    for (const item of order.items) {
      if (!this.inventoryService.checkAvailability(item.productId, item.quantity)) {
        return {
          success: false,
          error: `Product ${item.productId} is not available in the requested quantity`
        };
      }
    }
    
    // Reserve inventory
    for (const item of order.items) {
      this.inventoryService.reserveItems(item.productId, item.quantity);
    }
    
    // Calculate shipping cost
    const shippingCost = this.shippingService.calculateShippingCost(order.shippingAddress, order.items);
    const totalAmount = order.subtotal + shippingCost;
    
    // Process payment
    try {
      const paymentResult = this.paymentProcessor.processPayment(
        order.id,
        totalAmount,
        order.paymentMethod
      );
      
      if (!paymentResult.success) {
        // Release inventory if payment fails
        for (const item of order.items) {
          this.inventoryService.releaseItems(item.productId, item.quantity);
        }
        
        return {
          success: false,
          error: "Payment processing failed"
        };
      }
      
      // Create shipping label
      const shippingResult = this.shippingService.createShippingLabel(
        order.id,
        order.shippingAddress,
        order.items
      );
      
      // Send notifications
      this.notificationService.sendOrderConfirmation(
        order.id,
        order.customerEmail,
        {
          items: order.items,
          subtotal: order.subtotal,
          shippingCost: shippingCost,
          total: totalAmount,
          paymentMethod: order.paymentMethod,
          shippingAddress: order.shippingAddress
        }
      );
      
      this.notificationService.sendShippingConfirmation(
        order.id,
        order.customerEmail,
        shippingResult.trackingNumber
      );
      
      return {
        success: true,
        orderId: order.id,
        paymentTransaction: paymentResult.transactionId,
        trackingNumber: shippingResult.trackingNumber,
        estimatedDelivery: shippingResult.estimatedDelivery
      };
      
    } catch (error) {
      // Release inventory on any error
      for (const item of order.items) {
        this.inventoryService.releaseItems(item.productId, item.quantity);
      }
      
      return {
        success: false,
        error: error.message
      };
    }
  }
}

// Sample order data
const order = {
  id: "ORD-12345",
  customerEmail: "customer@example.com",
  items: [
    { productId: 1, name: "Product 1", price: 25.99, quantity: 2 },
    { productId: 2, name: "Product 2", price: 15.49, quantity: 1 }
  ],
  subtotal: 67.47,
  paymentMethod: {
    type: "credit_card",
    cardNumber: "4111111111111111",
    expiryDate: "12/25",
    cvv: "123"
  },
  shippingAddress: {
    street: "123 Main St",
    city: "Anytown",
    state: "CA",
    zip: "12345",
    country: "USA"
  }
};

// Create the services
const inventoryService = new WarehouseInventoryService();
const paymentProcessor = new StripePaymentProcessor();
const shippingService = new FedExShippingService();
const notificationService = new EmailNotificationService();

// Create the order processor
const orderProcessor = new OrderProcessor(
  inventoryService,
  paymentProcessor,
  shippingService,
  notificationService
);

// Process the order
(async () => {
  const result = await orderProcessor.processOrder(order);
  console.log("Order processing result:", result);
})();
```

This comprehensive example demonstrates a real-world application of DIP. The high-level `OrderProcessor` depends on abstractions for inventory, payment, shipping, and notifications, making it flexible and testable.

## Techniques for Applying DIP in JavaScript

### 1. Dependency Injection

Provide dependencies from the outside rather than creating them internally:

```javascript
// Instead of this:
class Service {
  constructor() {
    this.database = new Database(); // Hardcoded dependency
  }
}

// Do this:
class Service {
  constructor(database) {
    this.database = database; // Injected dependency
  }
}
```

### 2. Inversion of Control (IoC) Containers

Use containers to manage dependencies and their lifecycle:

```javascript
class IoContainer {
  constructor() {
    this.services = new Map();
  }
  
  register(name, instance) {
    this.services.set(name, instance);
  }
  
  resolve(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not registered`);
    }
    return service;
  }
}

const container = new IoContainer();
container.register('logger', new ConsoleLogger());
container.register('database', new MySQLDatabase());

const logger = container.resolve('logger');
const database = container.resolve('database');
```

### 3. Factory Functions

Use factory functions to create objects without direct instantiation:

```javascript
// Factory for creating API clients
function createApiClient(type, config) {
  switch (type) {
    case 'rest':
      return new RestApiClient(config);
    case 'graphql':
      return new GraphQLClient(config);
    default:
      throw new Error(`Unknown API client type: ${type}`);
  }
}

// Usage
const apiClient = createApiClient('rest', { baseUrl: 'https://api.example.com' });
```

### 4. Strategy Pattern

Use the strategy pattern to swap implementations at runtime:

```javascript
class SortingContext {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  sort(data) {
    return this.strategy.sort(data);
  }
}

class BubbleSortStrategy {
  sort(data) {
    console.log("Sorting with bubble sort");
    // Bubble sort implementation
    return [...data].sort();
  }
}

class QuickSortStrategy {
  sort(data) {
    console.log("Sorting with quick sort");
    // Quick sort implementation
    return [...data].sort();
  }
}

// Usage
const sorter = new SortingContext(new BubbleSortStrategy());
sorter.sort([3, 1, 4, 1, 5, 9]);

// Change strategy at runtime
sorter.setStrategy(new QuickSortStrategy());
sorter.sort([3, 1, 4, 1, 5, 9]);
```

### 5. Adapter Pattern

Use adapters to convert between different interfaces:

```javascript
// Third-party library that doesn't match our interface
class ThirdPartyPaymentGateway {
  charge(amount, card) {
    console.log(`Charging ${amount} to card ${card.number}`);
    return { success: true, reference: "ref123" };
  }
}

// Our payment processor interface
class PaymentProcessor {
  processPayment(order) {
    throw new Error("Method 'processPayment()' must be implemented");
  }
}

// Adapter that makes the third-party gateway conform to our interface
class PaymentGatewayAdapter extends PaymentProcessor {
  constructor(gateway) {
    super();
    this.gateway = gateway;
  }
  
  processPayment(order) {
    return this.gateway.charge(order.total, {
      number: order.paymentDetails.cardNumber,
      expiry: order.paymentDetails.expiryDate,
      cvv: order.paymentDetails.cvv
    });
  }
}

// Usage
const thirdPartyGateway = new ThirdPartyPaymentGateway();
const paymentProcessor = new PaymentGatewayAdapter(thirdPartyGateway);
paymentProcessor.processPayment({
  total: 99.99,
  paymentDetails: {
    cardNumber: "4111111111111111",
    expiryDate: "12/25",
    cvv: "123"
  }
});
```

## Common Challenges and Solutions

### 1. Identifying the Right Abstractions

It can be challenging to identify the right abstractions, especially in complex systems.

**Solution**: Focus on the behaviors and responsibilities rather than the implementation details. Look for stable interfaces that are unlikely to change even as the implementations evolve.

### 2. Balancing Flexibility and Complexity

DIP can lead to more complex code with more moving parts, which can be overwhelming for simple applications.

**Solution**: Apply DIP judiciously. For smaller applications or components where change is unlikely, it might be acceptable to use concrete implementations directly. Focus on applying DIP to areas that are likely to change or need testing.

### 3. Managing Dependencies in Large Applications

As applications grow, managing dependencies can become complex.

**Solution**: Use dependency injection frameworks or IoC containers to manage dependencies. Popular options for JavaScript include Inversify, Awilix, and Bottle.js.

```javascript
// Using Inversify (a popular DI container for TypeScript)
import { Container, injectable, inject } from "inversify";
import "reflect-metadata";

interface Logger {
  log(message: string): void;
}

interface Database {
  query(sql: string): any[];
}

@injectable()
class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }
}

@injectable()
class MySQLDatabase implements Database {
  query(sql: string): any[] {
    console.log(`Executing query: ${sql}`);
    return [];
  }
}

@injectable()
class UserService {
  private logger: Logger;
  private database: Database;
  
  constructor(
    @inject("Logger") logger: Logger,
    @inject("Database") database: Database
  ) {
    this.logger = logger;
    this.database = database;
  }
  
  getUsers() {
    this.logger.log("Getting users");
    return this.database.query("SELECT * FROM users");
  }
}

const container = new Container();
container.bind<Logger>("Logger").to(ConsoleLogger);
container.bind<Database>("Database").to(MySQLDatabase);
container.bind<UserService>("UserService").to(UserService);

const userService = container.get<UserService>("UserService");
userService.getUsers();
```

### 4. Testing with DIP

DIP makes testing easier, but setup can still be complex.

**Solution**: Use test doubles (mocks, stubs, fakes) to simplify testing and isolate the component under test.

```javascript
// Example with Jest mocks
const mockLogger = {
  log: jest.fn()
};

const mockDatabase = {
  query: jest.fn().mockReturnValue([{ id: 1, name: 'Test User' }])
};

const userService = new UserService(mockLogger, mockDatabase);
const users = userService.getUsers();

expect(mockLogger.log).toHaveBeenCalledWith('Getting users');
expect(mockDatabase.query).toHaveBeenCalledWith('SELECT * FROM users');
expect(users).toEqual([{ id: 1, name: 'Test User' }]);
```

## Real-World Benefits of DIP

- **Easier Testing**: With DIP, you can easily replace real dependencies with test doubles
- **Flexibility**: You can swap implementations without changing client code
- **Modularity**: The system becomes more modular and components are more reusable
- **Stability**: High-level modules containing business logic are insulated from changes in low-level modules
- **Easier Maintenance**: Changes are more isolated and have less ripple effect through the system

## When to Be Flexible with DIP

While DIP is valuable, there are times when strict adherence isn't practical:

- **Simple Applications**: For small applications or scripts, the overhead of DIP might not be justified
- **Prototypes**: When rapidly prototyping, it might be faster to use concrete implementations directly
- **Stable Dependencies**: For dependencies that are unlikely to change (like standard libraries), direct dependencies might be acceptable
- **Performance-Critical Code**: Abstractions can introduce overhead, which might be problematic in performance-critical sections

## Design Patterns That Help with DIP

Several design patterns can help implement DIP:

### 1. Factory Method Pattern

Defer instantiation to subclasses:

```javascript
class Creator {
  create() {
    const product = this.factoryMethod();
    return product;
  }
  
  factoryMethod() {
    throw new Error("Method 'factoryMethod()' must be implemented by subclasses");
  }
}

class ConcreteCreatorA extends Creator {
  factoryMethod() {
    return new ConcreteProductA();
  }
}

class ConcreteCreatorB extends Creator {
  factoryMethod() {
    return new ConcreteProductB();
  }
}

// The Product interface
class Product {
  operation() {
    throw new Error("Method 'operation()' must be implemented");
  }
}

class ConcreteProductA extends Product {
  operation() {
    return "Result of ConcreteProductA";
  }
}

class ConcreteProductB extends Product {
  operation() {
    return "Result of ConcreteProductB";
  }
}

// Usage
function clientCode(creator) {
  console.log("Client: I'm not aware of the creator's class, but it still works.");
  console.log(creator.create().operation());
}

clientCode(new ConcreteCreatorA());
clientCode(new ConcreteCreatorB());
```

### 2. Abstract Factory Pattern

Create families of related objects without specifying their concrete classes:

```javascript
// Abstract products
class Button {
  render() {
    throw new Error("Method 'render()' must be implemented");
  }
  
  onClick() {
    throw new Error("Method 'onClick()' must be implemented");
  }
}

class Checkbox {
  render() {
    throw new Error("Method 'render()' must be implemented");
  }
  
  toggle() {
    throw new Error("Method 'toggle()' must be implemented");
  }
}

// Concrete products for Windows
class WindowsButton extends Button {
  render() {
    console.log("Rendering Windows button");
  }
  
  onClick() {
    console.log("Windows button clicked");
  }
}

class WindowsCheckbox extends Checkbox {
  render() {
    console.log("Rendering Windows checkbox");
  }
  
  toggle() {
    console.log("Windows checkbox toggled");
  }
}

// Concrete products for macOS
class MacOSButton extends Button {
  render() {
    console.log("Rendering macOS button");
  }
  
  onClick() {
    console.log("macOS button clicked");
  }
}

class MacOSCheckbox extends Checkbox {
  render() {
    console.log("Rendering macOS checkbox");
  }
  
  toggle() {
    console.log("macOS checkbox toggled");
  }
}

// Abstract factory
class GUIFactory {
  createButton() {
    throw new Error("Method 'createButton()' must be implemented");
  }
  
  createCheckbox() {
    throw new Error("Method 'createCheckbox()' must be implemented");
  }
}

// Concrete factories
class WindowsFactory extends GUIFactory {
  createButton() {
    return new WindowsButton();
  }
  
  createCheckbox() {
    return new WindowsCheckbox();
  }
}

class MacOSFactory extends GUIFactory {
  createButton() {
    return new MacOSButton();
  }
  
  createCheckbox() {
    return new MacOSCheckbox();
  }
}

// Client code
class Application {
  constructor(factory) {
    this.factory = factory;
    this.button = null;
    this.checkbox = null;
  }
  
  createUI() {
    this.button = this.factory.createButton();
    this.checkbox = this.factory.createCheckbox();
  }
  
  paint() {
    this.button.render();
    this.checkbox.render();
  }
}

// Usage
function clientCode(os) {
  let factory;
  if (os === "Windows") {
    factory = new WindowsFactory();
  } else if (os === "macOS") {
    factory = new MacOSFactory();
  } else {
    throw new Error("Unknown OS");
  }
  
  const app = new Application(factory);
  app.createUI();
  app.paint();
}

clientCode("Windows");
clientCode("macOS");
```

### 3. Service Locator Pattern

Centralize the instantiation and location of services:

```javascript
class ServiceLocator {
  constructor() {
    this.services = new Map();
    this.cache = new Map();
  }
  
  register(name, factory, singleton = false) {
    this.services.set(name, { factory, singleton });
    // Clear cache when re-registering
    if (this.cache.has(name)) {
      this.cache.delete(name);
    }
  }
  
  get(name) {
    const service = this.services.get(name);
    
    if (!service) {
      throw new Error(`Service '${name}' not registered`);
    }
    
    if (service.singleton) {
      if (!this.cache.has(name)) {
        this.cache.set(name, service.factory());
      }
      return this.cache.get(name);
    }
    
    return service.factory();
  }
}

// Example services
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class Database {
  constructor(connectionString) {
    this.connectionString = connectionString;
    console.log(`Connected to database: ${connectionString}`);
  }
  
  query(sql) {
    console.log(`Executing query: ${sql}`);
    return [{ id: 1, name: "John" }];
  }
}

// Create service locator
const locator = new ServiceLocator();

// Register services
locator.register("logger", () => new Logger(), true); // Singleton
locator.register("database", () => new Database("mysql://localhost:3306/mydb"), true); // Singleton

// Client code
class UserService {
  constructor(serviceLocator) {
    this.serviceLocator = serviceLocator;
  }
  
  getUsers() {
    const logger = this.serviceLocator.get("logger");
    const database = this.serviceLocator.get("database");
    
    logger.log("Getting users");
    return database.query("SELECT * FROM users");
  }
}

// Usage
const userService = new UserService(locator);
userService.getUsers();
```

### 4. Dependency Injection (DI) Container

Automate dependency injection with a container:

```javascript
class DIContainer {
  constructor() {
    this.registrations = new Map();
    this.instances = new Map();
  }
  
  // Register a type with its dependencies
  register(name, type, dependencies = []) {
    this.registrations.set(name, { type, dependencies });
  }
  
  // Get an instance of a type, resolving all dependencies
  resolve(name) {
    // Return cached instance if available
    if (this.instances.has(name)) {
      return this.instances.get(name);
    }
    
    const registration = this.registrations.get(name);
    
    if (!registration) {
      throw new Error(`No registration for ${name}`);
    }
    
    // Resolve dependencies
    const dependencies = registration.dependencies.map(dep => this.resolve(dep));
    
    // Create instance
    const instance = new registration.type(...dependencies);
    
    // Cache the instance
    this.instances.set(name, instance);
    
    return instance;
  }
}

// Example classes with dependencies
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class Database {
  constructor(logger) {
    this.logger = logger;
    this.logger.log("Database initialized");
  }
  
  query(sql) {
    this.logger.log(`Executing query: ${sql}`);
    return [{ id: 1, name: "John" }];
  }
}

class UserService {
  constructor(logger, database) {
    this.logger = logger;
    this.database = database;
  }
  
  getUsers() {
    this.logger.log("Getting users");
    return this.database.query("SELECT * FROM users");
  }
}

// Set up the DI container
const container = new DIContainer();
container.register("logger", Logger);
container.register("database", Database, ["logger"]);
container.register("userService", UserService, ["logger", "database"]);

// Resolve the service with all its dependencies
const userService = container.resolve("userService");
userService.getUsers();
```

### 5. Plugin Architecture Pattern

Create extensible systems where new functionality can be added without modifying existing code:

```javascript
// Plugin interface
class Plugin {
  initialize(host) {
    throw new Error("Method 'initialize()' must be implemented");
  }
  
  getName() {
    throw new Error("Method 'getName()' must be implemented");
  }
  
  getVersion() {
    throw new Error("Method 'getVersion()' must be implemented");
  }
}

// Plugin host
class PluginHost {
  constructor() {
    this.plugins = new Map();
  }
  
  registerPlugin(plugin) {
    plugin.initialize(this);
    this.plugins.set(plugin.getName(), plugin);
    console.log(`Plugin registered: ${plugin.getName()} v${plugin.getVersion()}`);
  }
  
  getPlugin(name) {
    return this.plugins.get(name);
  }
  
  executePluginMethod(name, method, ...args) {
    const plugin = this.getPlugin(name);
    if (!plugin || typeof plugin[method] !== 'function') {
      throw new Error(`Plugin ${name} does not have method ${method}`);
    }
    return plugin[method](...args);
  }
}

// Concrete plugins
class LoggingPlugin extends Plugin {
  initialize(host) {
    this.host = host;
    console.log("Logging plugin initialized");
  }
  
  getName() {
    return "logging";
  }
  
  getVersion() {
    return "1.0.0";
  }
  
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class ValidationPlugin extends Plugin {
  initialize(host) {
    this.host = host;
    console.log("Validation plugin initialized");
  }
  
  getName() {
    return "validation";
  }
  
  getVersion() {
    return "1.0.0";
  }
  
  validate(data, rules) {
    console.log(`Validating data against rules: ${JSON.stringify(rules)}`);
    return true; // Simplified validation
  }
}

// Usage
const host = new PluginHost();
host.registerPlugin(new LoggingPlugin());
host.registerPlugin(new ValidationPlugin());

// Using plugins
host.executePluginMethod("logging", "log", "This is a log message");
const isValid = host.executePluginMethod("validation", "validate", { name: "John" }, { name: "required" });
console.log(`Validation result: ${isValid}`);
```

### 6. Strategy Pattern

Define a family of algorithms, encapsulate each one, and make them interchangeable:

```javascript
// Strategy interface
class PaymentStrategy {
  pay(amount) {
    throw new Error("Method 'pay()' must be implemented");
  }
}

// Concrete strategies
class CreditCardStrategy extends PaymentStrategy {
  constructor(name, cardNumber, cvv, expiryDate) {
    super();
    this.name = name;
    this.cardNumber = cardNumber;
    this.cvv = cvv;
    this.expiryDate = expiryDate;
  }
  
  pay(amount) {
    console.log(`Paid ${amount} using Credit Card (${this.cardNumber})`);
  }
}

class PayPalStrategy extends PaymentStrategy {
  constructor(email, password) {
    super();
    this.email = email;
    this.password = password;
  }
  
  pay(amount) {
    console.log(`Paid ${amount} using PayPal (${this.email})`);
  }
}

class BitcoinStrategy extends PaymentStrategy {
  constructor(address) {
    super();
    this.address = address;
  }
  
  pay(amount) {
    console.log(`Paid ${amount} using Bitcoin (${this.address})`);
  }
}

// Context
class ShoppingCart {
  constructor() {
    this.items = [];
    this.paymentStrategy = null;
  }
  
  addItem(item) {
    this.items.push(item);
  }
  
  calculateTotal() {
    return this.items.reduce((total, item) => total + item.price, 0);
  }
  
  setPaymentStrategy(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }
  
  checkout() {
    if (!this.paymentStrategy) {
      throw new Error("No payment strategy set");
    }
    
    const amount = this.calculateTotal();
    this.paymentStrategy.pay(amount);
  }
}

// Usage
const cart = new ShoppingCart();
cart.addItem({ name: "Product 1", price: 50 });
cart.addItem({ name: "Product 2", price: 75 });

// Pay with Credit Card
cart.setPaymentStrategy(new CreditCardStrategy("John Doe", "1234-5678-9012-3456", "123", "12/25"));
cart.checkout();

// Pay with PayPal
cart.setPaymentStrategy(new PayPalStrategy("john@example.com", "password"));
cart.checkout();

// Pay with Bitcoin
cart.setPaymentStrategy(new BitcoinStrategy("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"));
cart.checkout();
```

### 7. Adapter Pattern

Allow classes with incompatible interfaces to work together:

```javascript
// Existing interface
class OldPaymentProcessor {
  makePayment(amount, currency, source) {
    console.log(`Processing payment of ${amount} ${currency}`);
    return { success: true, id: `payment-${Date.now()}` };
  }
  
  refundPayment(paymentId, amount) {
    console.log(`Refunding payment ${paymentId} for ${amount}`);
    return { success: true };
  }
}

// New desired interface
class PaymentGateway {
  processPayment(paymentInfo) {
    throw new Error("Method 'processPayment()' must be implemented");
  }
  
  issueRefund(refundInfo) {
    throw new Error("Method 'issueRefund()' must be implemented");
  }
}

// Adapter to make OldPaymentProcessor work with the new interface
class PaymentProcessorAdapter extends PaymentGateway {
  constructor(oldProcessor) {
    super();
    this.processor = oldProcessor;
  }
  
  processPayment(paymentInfo) {
    const result = this.processor.makePayment(
      paymentInfo.amount,
      paymentInfo.currency,
      paymentInfo.source
    );
    
    return {
      successful: result.success,
      transactionId: result.id,
      timestamp: new Date()
    };
  }
  
  issueRefund(refundInfo) {
    const result = this.processor.refundPayment(
      refundInfo.transactionId,
      refundInfo.amount
    );
    
    return {
      successful: result.success,
      timestamp: new Date()
    };
  }
}

// Client code that works with the new interface
class CheckoutService {
  constructor(paymentGateway) {
    this.paymentGateway = paymentGateway;
  }
  
  processCheckout(order) {
    console.log(`Processing checkout for order ${order.id}`);
    
    const paymentResult = this.paymentGateway.processPayment({
      amount: order.total,
      currency: order.currency,
      source: order.paymentSource
    });
    
    if (paymentResult.successful) {
      console.log(`Checkout successful, transaction ID: ${paymentResult.transactionId}`);
      return { success: true, order, payment: paymentResult };
    } else {
      console.log("Checkout failed");
      return { success: false, error: "Payment processing failed" };
    }
  }
  
  processRefund(order, amount) {
    const refundResult = this.paymentGateway.issueRefund({
      transactionId: order.payment.transactionId,
      amount: amount
    });
    
    if (refundResult.successful) {
      console.log(`Refund successful for order ${order.id}`);
      return { success: true };
    } else {
      console.log(`Refund failed for order ${order.id}`);
      return { success: false, error: "Refund processing failed" };
    }
  }
}

// Usage with the adapter
const oldProcessor = new OldPaymentProcessor();
const adapter = new PaymentProcessorAdapter(oldProcessor);
const checkoutService = new CheckoutService(adapter);

const order = {
  id: "ORD-12345",
  total: 99.99,
  currency: "USD",
  paymentSource: "credit_card"
};

const checkoutResult = checkoutService.processCheckout(order);
if (checkoutResult.success) {
  // Later on...
  checkoutService.processRefund(checkoutResult, 99.99);
}
```

## When to Use Each Pattern

- **Factory Method**: When a class can't anticipate the type of objects it must create, or when a class wants its subclasses to specify the objects it creates.

- **Abstract Factory**: When your system needs to be independent from the way the products it works with are created, or when you have families of related objects designed to be used together.

- **Service Locator**: When you want to centralize the instantiation logic but don't need the full power of a DI container, or in performance-sensitive applications where DI might introduce overhead.

- **DI Container**: When you have a complex object graph with many dependencies, especially in large applications where manual instantiation would be error-prone and tedious.

- **Plugin Architecture**: When you need to create an extensible system where third-party developers can add new functionality without modifying the core code.

- **Strategy Pattern**: When you want to define a family of algorithms, encapsulate each one, and make them interchangeable, or when you have multiple ways to perform an operation and need to select one at runtime.

- **Adapter Pattern**: When you need to make existing classes work with others without modifying their source code, or when you're integrating with third-party libraries that have incompatible interfaces.

## Conclusion

The Dependency Inversion Principle is a powerful tool for creating flexible, maintainable, and testable applications. By depending on abstractions rather than concrete implementations, you create systems that are more resilient to change and easier to extend.

These design patterns provide practical ways to implement DIP in your JavaScript applications. Each pattern has its strengths and weaknesses, so choose the one that best fits your specific requirements and constraints.

Remember that DIP is not an all-or-nothing principle. It's okay to start small, applying it to the parts of your application that are most likely to change or need testing, and gradually expanding as your application grows and evolves.